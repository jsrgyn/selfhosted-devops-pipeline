#docker-compose.yml
version: "3.8"
services:
  # Nginx - Reverse Proxy
  nginx:
    #extra_hosts:
    #  - "host.docker.internal:host-gateway"
    #  - "gitea.local:172.18.0.1" # Use o IP do Nginx ou do Host Gateway
    #  - "drone.local:172.18.0.1"
    #  - "sonar.local:172.18.0.1"
    image: nginx:alpine
    container_name: nginx_proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx/conf.d:/etc/nginx/conf.d:ro  # Monta o diretório inteiro
      - ./nginx/html/dashboard:/usr/share/nginx/html/dashboard:ro
      - ./nginx/html:/usr/share/nginx/html/errors:ro
      - ./nginx/ssl:/etc/nginx/ssl:ro
    networks:
      - gitea-network
    #environment:
    #  - NGINX_ENVSUBST_TEMPLATE_DIR=/etc/nginx/templates
    #  - NGINX_ENVSUBST_OUTPUT_DIR=/etc/nginx/conf.d
    depends_on:
      - gitea
      - sonarqube
      - drone-server
    healthcheck:
      test: ["CMD", "nginx", "-t"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
  gitea:
    extra_hosts:
      - "host.docker.internal:host-gateway"
      - "drone.local:172.18.0.1"
    image: gitea/gitea:1.21
    container_name: gitea
    restart: unless-stopped
    environment:
      - USER_UID=${USER_UID}
      - USER_GID=${USER_GID}
      - GITEA__database__DB_TYPE=postgres
      - GITEA__database__HOST=postgres_dbx:5432
      - GITEA__database__NAME=${GITEA_DATABASE}
      - GITEA__database__USER=${GITEA_DATABASE_USER}
      - GITEA__database__PASSWD=${GITEA_DATABASE_PASSWORD}
      - GITEA__database__SSL_MODE=disable
      - GITEA__server__DOMAIN=${GITEA_DOMAIN}
      - GITEA__server__SSH_DOMAIN=${GITEA_DOMAIN}
      - GITEA__server__ROOT_URL=${GITEA_ROOT_URL}
      - GITEA__server__HTTP_PORT=3000
      #- GITEA__server__SSH_PORT=2222
      - GITEA__server__DISABLE_SSH=true
      - GITEA__server__START_SSH_SERVER=false
      - GITEA__server__LFS_START_SERVER=false
      - GITEA__server__OFFLINE_MODE=false
      # OAuth2 Settings
      - GITEA__oauth2__ENABLE=true
      - GITEA__oauth2__JWT_SECRET=${GITEA_OAUTH2_JWT_SECRET}
      # Security Settings
      - GITEA__security__SECRET_KEY=${GITEA_SECRET_KEY}
      - GITEA__security__INTERNAL_TOKEN=${GITEA_INTERNAL_TOKEN}
      # Session Settings
      - GITEA__session__PROVIDER=file
      - GITEA__session__PROVIDER_CONFIG=data/sessions
      # Log Settings
      - GITEA__log__MODE=console,file
      - GITEA__log__LEVEL=Info
      - GITEA__log__ROOT_PATH=/data/gitea/log
      # --- Bloco de Segurança do Proxy ---
      # Diz ao Gitea que ele está atrás de um proxy
      - GITEA__server__ENABLE_REVERSE_PROXY_AUTHENTICATION=false
      - GITEA__server__ENABLE_REVERSE_PROXY_AUTO_REGISTRATION=false
      - GITEA__server__ENABLE_REVERSE_PROXY_EMAIL=false
      # Diz ao Gitea para confiar nos cabeçalhos de CADA IP na rede privada
      - GITEA__server__REVERSE_PROXY_TRUSTED_PROXIES=10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16
    networks:
      - gitea-network
    volumes:
      - ./data:/data
      - ./config:/etc/gitea
      - /etc/timezone:/etc/timezone:ro
      - /etc/localtime:/etc/localtime:ro
    #ports:
      # - "${GITEA_HTTP_PORT}:3000"
      # - "${GITEA_SSH_PORT}:22"
    depends_on:
      postgres_dbx:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s

  # Drone Server - CI/CD Server
  drone-server:
    extra_hosts:
      - "host.docker.internal:host-gateway"
      - "gitea.local:172.18.0.1" # Use o IP do Nginx ou do Host Gateway 
      #- "gitea.local:172.18.0.3" # Use o IP do Nginx ou do Host Gateway 
    image: drone/drone:2.20
    container_name: drone_server
    restart: unless-stopped
    environment:
      # Drone Settings
      #- DRONE_GITEA_SERVER=${GITEA_ROOT_REDE}
      - DRONE_GITEA_SERVER=http://gitea.local
      - DRONE_GITEA_CLIENT_ID=${DRONE_GITEA_CLIENT_ID}
      - DRONE_GITEA_CLIENT_SECRET=${DRONE_GITEA_CLIENT_SECRET}
      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET}
      - DRONE_RPC_HOST=${DRONE_RPC_HOST}
      # Esta configuração define a URL PÚBLICA do seu Drone
      - DRONE_SERVER_HOST=${DRONE_SERVER_HOST}
      #- DRONE_UI_PATH=${DRONE_UI_PATH}
      - DRONE_SERVER_PROTO=${DRONE_SERVER_PROTO}
      #- DRONE_SERVER_PORT=:80
      # Database Settings
      - DRONE_DATABASE_DRIVER=postgres
      - DRONE_DATABASE_DATASOURCE=postgres://${DRONE_DATABASE_USER}:${DRONE_DATABASE_PASSWORD}@postgres_dbx:5432/${DRONE_DATABASE}?sslmode=disable
      # User Settings
      - DRONE_USER_CREATE=username:${DRONE_ADMIN_USER},admin:true
      # Security Settings
      - DRONE_LOGS_PRETTY=true
      - DRONE_LOGS_COLOR=true
      - DRONE_GITEA_URL=http://gitea.local 
      # Webhook Settings
      - DRONE_WEBHOOK_ENDPOINT=${DRONE_WEBHOOK_ENDPOINT}
      - DRONE_WEBHOOK_SECRET=${DRONE_WEBHOOK_SECRET}
      # Runner Settings
      - DRONE_AGENTS_ENABLED=true
    networks:
      - gitea-network
    volumes:
      - drone_data:/data
      #- /var/run/docker.sock:/var/run/docker.sock
    depends_on:
      postgres_dbx:
        condition: service_healthy
      gitea:
        condition: service_healthy

  # Drone Runner - CI/CD Runner
  # -------------------- DRONE SSH RUNNER --------------------
  drone-runner-ssh:
    image: drone/drone-runner-ssh:latest # Nova imagem do runner
    container_name: drone_runner_ssh
    restart: unless-stopped
    environment:
      - DRONE_RPC_PROTO=${DRONE_SERVER_PROTO}
      - DRONE_RPC_HOST=${DRONE_RPC_HOST}
      - DRONE_RPC_SECRET=${DRONE_RPC_SECRET}
      - DRONE_RUNNER_CAPACITY=2
      - DRONE_RUNNER_NAME=${DRONE_RUNNER_NAME}
      #- DRONE_RUNNER_LABELS=environment:development,arch:arm64
      - DRONE_RUNNER_LABELS=environment:ssh-build,arch:arm64
      - DRONE_LOGS_PRETTY=true
      - DRONE_LOGS_COLOR=true
    networks:
      - gitea-network
    volumes:
      - ./ssh/id_rsa:/id_rsa:ro
    depends_on:
      drone-server:
        condition: service_started
   # -------------------- SERVIDOR DE BUILD NODE.JS (NOVO) --------------------
  build-server-node:
    extra_hosts:
      - "host.docker.internal:host-gateway"
      - "gitea.local:172.18.0.1"
      - "sonar.local:172.18.0.1"
    # Imagem baseada em Ubuntu com SSH e Node.js para ARM64
    #image: sickp/alpine-sshd:latest
    image: devops-build-server:latest
    container_name: build_server_node
    hostname: build-server-node # Define o hostname dentro da rede
    restart: unless-stopped
    environment:
      # Configura o usuário e a senha para o acesso SSH do runner
      - SSH_ENABLE_ROOT=true
      - SSH_USER_PASSWORD_LOCK=true # Desativa login com senha
    networks:
      - gitea-network
    volumes:
      # Monta sua chave PÚBLICA para permitir o login do runner
      - ./ssh/id_rsa.pub:/root/.ssh/authorized_keys:ro
      # Volume para persistir o node_modules e outras ferramentas de build
      - ./data/build-server:/root/builds
    ports:
       - 8000:8000 # Porta para acessar o servidor de build Node.js
  sonarqube:
    image: sonarqube:10.3-community
    container_name: sonarqube
    restart: unless-stopped
    environment:
      - SONAR_JDBC_URL=jdbc:postgresql://postgres_dbx:5432/${SONARQUBE_DB_NAME}
      - SONAR_JDBC_USERNAME=${SONARQUBE_DB_USER}
      - SONAR_JDBC_PASSWORD=${SONARQUBE_DB_PASSWORD}
      #- SONAR_WEB_CONTEXT=${SONAR_WEB_CONTEXT}
      - SONAR_ES_BOOTSTRAP_CHECKS_DISABLE=true
      - SONAR_WEB_HOST=0.0.0.0
      - SONAR_WEB_PORT=9000
    networks:
      - gitea-network
    volumes:
      - sonarqube_data:/opt/sonarqube/data
      - sonarqube_extensions:/opt/sonarqube/extensions
      - sonarqube_logs:/opt/sonarqube/logs
    depends_on:
      postgres_dbx:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/api/system/status"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 60s
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536

  postgres_dbx:
    image: postgres:15-alpine
    container_name: postgres_dbx
    restart: unless-stopped
    environment:
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --lc-collate=C --lc-ctype=C
      - PGDATA=/var/lib/postgresql/data/pgdata
    command: >
      postgres
      -c shared_preload_libraries=pg_stat_statements
      -c max_connections=200
      -c shared_buffers=256MB
      -c effective_cache_size=1GB
      -c maintenance_work_mem=64MB
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c work_mem=4MB
      -c min_wal_size=1GB
      -c max_wal_size=4GB
    networks:
      - gitea-network
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-postgres.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 30s
      timeout: 10s
      retries: 10
      start_period: 60s

networks:
  gitea-network:
    driver: bridge

volumes:
  postgres_data:
    driver: local
  sonarqube_data:
    driver: local
  sonarqube_extensions:
    driver: local
  sonarqube_logs:
    driver: local
  drone_data:
    driver: local
