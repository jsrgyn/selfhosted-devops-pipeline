# Makefile para DevOps Stack
# Uso: make [comando]

# VariÃ¡veis
COMPOSE_FILE = docker-compose.yml
PROJECT_NAME = devops-stack
BACKUP_DIR = ./backup/$(shell date +%Y%m%d_%H%M%S)

# Cores para output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[1;33m
BLUE = \033[0;34m
NC = \033[0m # No Color

.PHONY: help setup up down restart status logs clean backup restore health check-env

# Comando padrÃ£o
.DEFAULT_GOAL := help

## Comandos Principais
help: ## Exibe esta ajuda
	@echo "$(BLUE)DevOps Stack - Comandos DisponÃ­veis:$(NC)"
	@echo ""
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  $(YELLOW)%-15s$(NC) %s\n", $$1, $$2}' $(MAKEFILE_LIST)
	@echo ""
	@echo "$(GREEN)Exemplo de uso:$(NC)"
	@echo "  make setup    # Primeira configuraÃ§Ã£o"
	@echo "  make up       # Subir todos os serviÃ§os"
	@echo "  make logs     # Ver logs em tempo real"
	@echo ""

setup: ## ConfiguraÃ§Ã£o inicial do projeto
	@echo "$(BLUE)ğŸš€ Configurando o ambiente DevOps...$(NC)"
	@if [ ! -f .env ]; then \
		echo "$(YELLOW)âš ï¸  Criando .env a partir do template...$(NC)"; \
		cp .env.example .env; \
		echo "$(RED)â— IMPORTANTE: Configure suas variÃ¡veis no arquivo .env antes de continuar!$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)ğŸ“ Criando estrutura de diretÃ³rios...$(NC)"
	@mkdir -p config/{nginx/{conf.d,html/{dashboard,errors},ssl},gitea,drone,postgres/{init-scripts,conf}}
	@mkdir -p data/{gitea/{repositories,data,log,avatars},postgres,sonarqube/{data,extensions,logs},drone,build-server/{builds,cache,artifacts}}
	@mkdir -p secrets/{ssh,ssl/{certificates,keys},auth}
	@mkdir -p build/{nginx,build-server,custom-images}
	@mkdir -p scripts monitoring/{prometheus,grafana/{dashboards,provisioning},logs}
	@mkdir -p backup/{automated,manual,scripts} docs/{api-docs,architecture/{diagrams,decisions}}
	@mkdir -p tests/{integration,smoke,load}
	@echo "$(GREEN)ğŸ”‘ Configurando permissÃµes...$(NC)"
	@chmod 700 secrets/
	@chmod 600 secrets/ssh/* 2>/dev/null || true
	@echo "$(GREEN)ğŸ”§ Gerando chaves SSH se nÃ£o existirem...$(NC)"
	@if [ ! -f secrets/ssh/id_rsa ]; then \
		ssh-keygen -t rsa -b 4096 -f secrets/ssh/id_rsa -N "" -C "drone-runner@devops-stack"; \
	fi
	@echo "$(GREEN)ğŸ“‹ Criando arquivos de configuraÃ§Ã£o base...$(NC)"
	@$(MAKE) create-configs
	@echo "$(GREEN)âœ… Setup concluÃ­do! Execute 'make up' para iniciar os serviÃ§os.$(NC)"

create-configs: ## Cria arquivos de configuraÃ§Ã£o bÃ¡sicos
	@echo "$(BLUE)ğŸ“ Criando configuraÃ§Ãµes bÃ¡sicas...$(NC)"
	@if [ ! -f config/postgres/init-scripts/01-init-databases.sql ]; then \
		echo "-- Script de inicializaÃ§Ã£o dos bancos" > config/postgres/init-scripts/01-init-databases.sql; \
		echo "CREATE DATABASE gitea_db;" >> config/postgres/init-scripts/01-init-databases.sql; \
		echo "CREATE DATABASE drone_db;" >> config/postgres/init-scripts/01-init-databases.sql; \
		echo "CREATE DATABASE sonarqube_db;" >> config/postgres/init-scripts/01-init-databases.sql; \
	fi

up: check-env ## Inicia todos os serviÃ§os
	@echo "$(BLUE)ğŸš€ Iniciando o stack DevOps...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) up -d
	@echo "$(GREEN)âœ… ServiÃ§os iniciados com sucesso!$(NC)"
	@$(MAKE) status

down: ## Para todos os serviÃ§os
	@echo "$(YELLOW)ğŸ›‘ Parando todos os serviÃ§os...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) down
	@echo "$(GREEN)âœ… ServiÃ§os parados com sucesso!$(NC)"

restart: ## Reinicia todos os serviÃ§os
	@echo "$(BLUE)ğŸ”„ Reiniciando todos os serviÃ§os...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) restart
	@echo "$(GREEN)âœ… ServiÃ§os reiniciados com sucesso!$(NC)"

restart-service: ## Reinicia um serviÃ§o especÃ­fico (uso: make restart-service SERVICE=nginx)
	@if [ -z "$(SERVICE)" ]; then \
		echo "$(RED)â— Uso: make restart-service SERVICE=nome_do_servico$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)ğŸ”„ Reiniciando serviÃ§o $(SERVICE)...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) restart $(SERVICE)
	@echo "$(GREEN)âœ… ServiÃ§o $(SERVICE) reiniciado!$(NC)"

status: ## Mostra status dos serviÃ§os
	@echo "$(BLUE)ğŸ“Š Status dos serviÃ§os:$(NC)"
	@docker-compose -f $(COMPOSE_FILE) ps

logs: ## Mostra logs de todos os serviÃ§os em tempo real
	@echo "$(BLUE)ğŸ“‹ Logs em tempo real (Ctrl+C para sair):$(NC)"
	@docker-compose -f $(COMPOSE_FILE) logs -f

logs-service: ## Mostra logs de um serviÃ§o especÃ­fico (uso: make logs-service SERVICE=nginx)
	@if [ -z "$(SERVICE)" ]; then \
		echo "$(RED)â— Uso: make logs-service SERVICE=nome_do_servico$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)ğŸ“‹ Logs do serviÃ§o $(SERVICE):$(NC)"
	@docker-compose -f $(COMPOSE_FILE) logs -f $(SERVICE)

health: ## Verifica saÃºde dos serviÃ§os
	@echo "$(BLUE)ğŸ¥ Verificando saÃºde dos serviÃ§os...$(NC)"
	@./scripts/health-check.sh || echo "$(YELLOW)âš ï¸  Script de health check nÃ£o encontrado$(NC)"
	@docker-compose -f $(COMPOSE_FILE) ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"

## Comandos de Backup e Restore
backup: ## Executa backup completo
	@echo "$(BLUE)ğŸ’¾ Iniciando backup completo...$(NC)"
	@mkdir -p $(BACKUP_DIR)
	@echo "$(YELLOW)ğŸ“Š Backup do banco de dados...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) exec -T postgres_dbx pg_dumpall -U ${POSTGRES_USER} > $(BACKUP_DIR)/postgres_full_backup.sql
	@echo "$(YELLOW)ğŸ“ Backup dos volumes...$(NC)"
	@docker run --rm -v $(PWD)/data:/data -v $(PWD)/backup:/backup alpine tar czf /backup/$(shell basename $(BACKUP_DIR))/volumes_backup.tar.gz -C /data .
	@echo "$(YELLOW)ğŸ”§ Backup das configuraÃ§Ãµes...$(NC)"
	@tar czf $(BACKUP_DIR)/config_backup.tar.gz config/
	@echo "$(YELLOW)ğŸ”‘ Backup dos secrets (criptografado)...$(NC)"
	@tar czf $(BACKUP_DIR)/secrets_backup.tar.gz secrets/ && gpg --cipher-algo AES256 --compress-algo 1 --s2k-mode 3 --s2k-digest-algo SHA512 --s2k-count 65536 --symmetric --output $(BACKUP_DIR)/secrets_backup.tar.gz.gpg $(BACKUP_DIR)/secrets_backup.tar.gz && rm $(BACKUP_DIR)/secrets_backup.tar.gz
	@echo "$(GREEN)âœ… Backup completo salvo em: $(BACKUP_DIR)$(NC)"

backup-db: ## Backup apenas do banco de dados
	@echo "$(BLUE)ğŸ’¾ Backup do banco de dados...$(NC)"
	@mkdir -p backup/database
	@docker-compose -f $(COMPOSE_FILE) exec -T postgres_dbx pg_dumpall -U ${POSTGRES_USER} > backup/database/postgres_backup_$(shell date +%Y%m%d_%H%M%S).sql
	@echo "$(GREEN)âœ… Backup do banco concluÃ­do!$(NC)"

restore: ## Restaura backup (uso: make restore BACKUP_DIR=./backup/20231201_120000)
	@if [ -z "$(BACKUP_DIR)" ]; then \
		echo "$(RED)â— Uso: make restore BACKUP_DIR=caminho_do_backup$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)âš ï¸  ATENÃ‡ÃƒO: Esta operaÃ§Ã£o irÃ¡ sobrescrever dados existentes!$(NC)"
	@echo "$(YELLOW)Pressione Ctrl+C nos prÃ³ximos 10 segundos para cancelar...$(NC)"
	@sleep 10
	@echo "$(BLUE)ğŸ”„ Restaurando backup...$(NC)"
	@$(MAKE) down
	@echo "$(YELLOW)ğŸ“ Restaurando volumes...$(NC)"
	@docker run --rm -v $(PWD)/data:/data -v $(PWD)/backup:/backup alpine tar xzf /backup/$(shell basename $(BACKUP_DIR))/volumes_backup.tar.gz -C /data
	@echo "$(YELLOW)ğŸ”§ Restaurando configuraÃ§Ãµes...$(NC)"
	@tar xzf $(BACKUP_DIR)/config_backup.tar.gz
	@$(MAKE) up
	@sleep 30
	@echo "$(YELLOW)ğŸ“Š Restaurando banco de dados...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) exec -T postgres_dbx psql -U ${POSTGRES_USER} -d ${POSTGRES_DB} < $(BACKUP_DIR)/postgres_full_backup.sql
	@echo "$(GREEN)âœ… Restore concluÃ­do!$(NC)"

## Comandos de ManutenÃ§Ã£o
clean: ## Remove containers, volumes e imagens nÃ£o utilizadas
	@echo "$(YELLOW)ğŸ§¹ Limpando recursos nÃ£o utilizados...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) down -v --remove-orphans
	@docker system prune -f
	@docker volume prune -f
	@echo "$(GREEN)âœ… Limpeza concluÃ­da!$(NC)"

clean-all: ## Remove TUDO (cuidado!)
	@echo "$(RED)âš ï¸  ATENÃ‡ÃƒO: Esta operaÃ§Ã£o remove TODOS os dados!$(NC)"
	@echo "$(YELLOW)Pressione Ctrl+C nos prÃ³ximos 15 segundos para cancelar...$(NC)"
	@sleep 15
	@$(MAKE) down
	@docker-compose -f $(COMPOSE_FILE) down -v --remove-orphans --rmi all
	@docker system prune -af --volumes
	@sudo rm -rf data/
	@echo "$(RED)ğŸ—‘ï¸  Todos os dados foram removidos!$(NC)"

update: ## Atualiza as imagens dos containers
	@echo "$(BLUE)ğŸ”„ Atualizando imagens...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) pull
	@echo "$(GREEN)âœ… Imagens atualizadas!$(NC)"
	@echo "$(YELLOW)ğŸ’¡ Execute 'make restart' para aplicar as atualizaÃ§Ãµes$(NC)"

## Comandos de Desenvolvimento
dev: ## Inicia em modo de desenvolvimento
	@echo "$(BLUE)ğŸ› ï¸  Iniciando em modo desenvolvimento...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) -f docker-compose.dev.yml up -d
	@$(MAKE) status

build: ## ReconstrÃ³i as imagens customizadas
	@echo "$(BLUE)ğŸ”¨ Reconstruindo imagens...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) build --no-cache
	@echo "$(GREEN)âœ… Build concluÃ­do!$(NC)"

shell: ## Acesso shell a um container (uso: make shell SERVICE=nginx)
	@if [ -z "$(SERVICE)" ]; then \
		echo "$(RED)â— Uso: make shell SERVICE=nome_do_servico$(NC)"; \
		exit 1; \
	fi
	@docker-compose -f $(COMPOSE_FILE) exec $(SERVICE) /bin/sh

## Comandos de Monitoramento
monitor: ## Inicia stack de monitoramento
	@echo "$(BLUE)ğŸ“Š Iniciando monitoramento...$(NC)"
	@docker-compose -f $(COMPOSE_FILE) --profile monitoring up -d
	@echo "$(GREEN)âœ… Monitoramento ativo!$(NC)"

stats: ## Mostra estatÃ­sticas de uso dos containers
	@echo "$(BLUE)ğŸ“ˆ EstatÃ­sticas dos containers:$(NC)"
	@docker stats --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}\t{{.BlockIO}}"

## Comandos de SeguranÃ§a
security-scan: ## Executa scan de seguranÃ§a nos containers
	@echo "$(BLUE)ğŸ” Executando scan de seguranÃ§a...$(NC)"
	@docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
		-v $(PWD):/tmp/.hadolint/config \
		hadolint/hadolint:latest hadolint /tmp/.hadolint/config/*/Dockerfile || true
	@echo "$(GREEN)âœ… Scan de seguranÃ§a concluÃ­do!$(NC)"

generate-secrets: ## Gera novos secrets para os serviÃ§os
	@echo "$(BLUE)ğŸ”‘ Gerando novos secrets...$(NC)"
	@echo "GITEA_SECRET_KEY=$(shell openssl rand -hex 32)" > secrets/auth/gitea-secrets.env
	@echo "GITEA_INTERNAL_TOKEN=$(shell openssl rand -hex 32)" >> secrets/auth/gitea-secrets.env
	@echo "GITEA_OAUTH2_JWT_SECRET=$(shell openssl rand -hex 32)" >> secrets/auth/gitea-secrets.env
	@echo "DRONE_RPC_SECRET=$(shell openssl rand -hex 32)" > secrets/auth/drone-secrets.env
	@echo "$(GREEN)âœ… Secrets gerados em secrets/auth/$(NC)"
	@echo "$(YELLOW)ğŸ’¡ Adicione estes valores ao seu arquivo .env$(NC)"

## UtilitÃ¡rios
check-env: ## Verifica se o arquivo .env existe
	@if [ ! -f .env ]; then \
		echo "$(RED)â— Arquivo .env nÃ£o encontrado!$(NC)"; \
		echo "$(YELLOW)ğŸ’¡ Execute 'make setup' primeiro$(NC)"; \
		exit 1; \
	fi

info: ## Mostra informaÃ§Ãµes do ambiente
	@echo "$(BLUE)â„¹ï¸  InformaÃ§Ãµes do Ambiente:$(NC)"
	@echo "Projeto: $(PROJECT_NAME)"
	@echo "Compose File: $(COMPOSE_FILE)"
	@echo "Docker Version: $(shell docker --version)"
	@echo "Docker Compose Version: $(shell docker-compose --version)"
	@echo "Sistema: $(shell uname -a)"

ports: ## Lista as portas expostas
	@echo "$(BLUE)ğŸŒ Portas expostas:$(NC)"
	@echo "Nginx (HTTP): 80"
	@echo "Nginx (HTTPS): 443"
	@echo "PostgreSQL: 5432"
	@echo "Build Server: 8000"
	@echo ""
	@echo "$(BLUE)ğŸŒ Acessos via proxy:$(NC)"
	@echo "Gitea: https://gitea.local"
	@echo "Drone: https://drone.local"
	@echo "SonarQube: https://sonar.local"

test: ## Executa testes bÃ¡sicos de conectividade
	@echo "$(BLUE)ğŸ§ª Executando testes bÃ¡sicos...$(NC)"
	@./scripts/test-connectivity.sh || echo "$(YELLOW)âš ï¸  Script de teste nÃ£o encontrado$(NC)"

## Meta comandos
install-deps: ## Instala dependÃªncias do sistema
	@echo "$(BLUE)ğŸ“¦ Instalando dependÃªncias...$(NC)"
	@which docker >/dev/null || (echo "$(RED)â— Docker nÃ£o instalado$(NC)" && exit 1)
	@which docker-compose >/dev/null || (echo "$(RED)â— Docker Compose nÃ£o instalado$(NC)" && exit 1)
	@which make >/dev/null || (echo "$(RED)â— Make nÃ£o instalado$(NC)" && exit 1)
	@echo "$(GREEN)âœ… Todas as dependÃªncias estÃ£o instaladas!$(NC)"